#include "crypto.h"

#include <mbedtls/ctr_drbg.h>
#include <mbedtls/entropy.h>
#include <stdlib.h>
#include <string.h>

#include "output.h"

/** Maximum length of a string generated by mbedtls_strerror() **/
#define COMINIT_MBEDTLS_ERR_MAX_LEN 64

#define DER_BUFFER_SIZE 1600  ///< buffer size to hold RSAâ€‘4k key.

// Macro definition to support both MbedTLS 2 and 3 interfaces.
#if MBEDTLS_VERSION_MAJOR == 2

#define cominitMbedtlsVerify(ctx, mdAlg, hashlen, hash, sig) \
    mbedtls_rsa_rsassa_pss_verify((ctx), NULL, NULL, MBEDTLS_RSA_PUBLIC, (mdAlg), (hashlen), (hash), (sig))
#define cominitComputeSHA256(data, dataLen, dataHash) mbedtls_sha256_ret(data, dataLen, dataHash, 0);
#define cominitRsaSetPadding(pkCtx, err)                                                         \
    do {                                                                                         \
        mbedtls_rsa_set_padding(mbedtls_pk_rsa(pkCtx), MBEDTLS_RSA_PKCS_V21, MBEDTLS_MD_SHA256); \
        (err) = 0;                                                                               \
    } while (0)

#elif MBEDTLS_VERSION_MAJOR == 3

#define cominitMbedtlsVerify(ctx, mdAlg, hashlen, hash, sig) \
    mbedtls_rsa_rsassa_pss_verify((ctx), (mdAlg), (hashlen), (hash), (sig))
#define cominitComputeSHA256(data, dataLen, dataHash) mbedtls_sha256(data, dataLen, dataHash, 0);
#define cominitRsaSetPadding(pkCtx, err)                                                                 \
    do {                                                                                                 \
        (err) = mbedtls_rsa_set_padding(mbedtls_pk_rsa(pkCtx), MBEDTLS_RSA_PKCS_V21, MBEDTLS_MD_SHA256); \
    } while (0)
#else

#error "Only MbedTLS versions 2 and 3 are supported."

#endif

/** String buffer for mbedtls_strerror **/
static char cominitMbedtlsErrbuf[COMINIT_MBEDTLS_ERR_MAX_LEN];

int cominitCryptoVerifySignature(const uint8_t *data, size_t dataLen, const uint8_t *signature, const char *keyfile) {
    int err = 0;
    mbedtls_pk_context pkCtx;
    mbedtls_pk_init(&pkCtx);
    err = mbedtls_pk_parse_public_keyfile(&pkCtx, keyfile);
    if (err != 0) {
        mbedtls_strerror(err, cominitMbedtlsErrbuf, sizeof(cominitMbedtlsErrbuf));
        cominitErrPrint("Parsing of public key \'%s\' failed. %s", keyfile, cominitMbedtlsErrbuf);
        mbedtls_pk_free(&pkCtx);
        return -1;
    }
    mbedtls_pk_type_t keyType = mbedtls_pk_get_type(&pkCtx);
    if (keyType == MBEDTLS_PK_NONE) {
        cominitErrPrint("Could not get type of public key \'%s\'.", keyfile);
        mbedtls_pk_free(&pkCtx);
        return -1;
    }
    cominitInfoPrint("Keyfile \'%s\' successfully loaded.", keyfile);
    if (mbedtls_pk_can_do(&pkCtx, MBEDTLS_PK_RSA) == 0) {
        cominitErrPrint("The keyfile \'%s\' did not contain a valid RSA public key.", keyfile);
        mbedtls_pk_free(&pkCtx);
        return -1;
    }

    cominitRsaSetPadding(pkCtx, err);
    if (err != 0) {
        mbedtls_strerror(err, cominitMbedtlsErrbuf, sizeof(cominitMbedtlsErrbuf));
        cominitErrPrint("Could not set RSASSA-PSS-compatible padding for RSA context. %s", cominitMbedtlsErrbuf);
        mbedtls_pk_free(&pkCtx);
        return -1;
    }

    uint8_t dataHash[32];
    err = cominitComputeSHA256(data, dataLen, dataHash);

    if (err != 0) {
        mbedtls_strerror(err, cominitMbedtlsErrbuf, sizeof(cominitMbedtlsErrbuf));
        cominitErrPrint("Could not calculate sha256 hash of input data. %s", cominitMbedtlsErrbuf);
        mbedtls_pk_free(&pkCtx);
        return -1;
    }
    err = cominitMbedtlsVerify(mbedtls_pk_rsa(pkCtx), MBEDTLS_MD_SHA256, sizeof(dataHash), dataHash, signature);
    if (err != 0) {
        mbedtls_strerror(err, cominitMbedtlsErrbuf, sizeof(cominitMbedtlsErrbuf));
        cominitErrPrint("Signature verification failed. %s", cominitMbedtlsErrbuf);
        mbedtls_pk_free(&pkCtx);
        return -1;
    }
    mbedtls_pk_free(&pkCtx);
    return 0;
}

int cominitCreateSHA256DigestfromKeyfile(const char *keyfile, unsigned char *digest, size_t digestLen) {
    int result = EXIT_FAILURE;

    if (keyfile == NULL || digest == NULL || digestLen < SHA256_LEN) {
        cominitErrPrint("Invalid parameters");
    } else {
        mbedtls_pk_context pkCtx;
        mbedtls_pk_init(&pkCtx);
        int err = mbedtls_pk_parse_public_keyfile(&pkCtx, keyfile);
        if (err == 0) {
            unsigned char der[DER_BUFFER_SIZE] = {0};
            int derLen = mbedtls_pk_write_pubkey_der(&pkCtx, der, sizeof(der));
            if (derLen > 0) {
                const unsigned char *pubKeyDer = der + sizeof(der) - derLen;
                err = cominitComputeSHA256(pubKeyDer, (size_t)derLen, digest);
                if (err == 0) {
                    result = EXIT_SUCCESS;
                }
            }
        }
        mbedtls_pk_free(&pkCtx);
    }

    return result;
}

/**
 * Creates an unique string for DRBG (Deterministic Random Bit Generator) seeding.
 *
 * Adds uniqueness (context specific salt) to
 * avoid identical DRBG states across devices with identical entropy sources.
 *
 * @param uniqueString  The pointer to receive the unique string.
 *
 * @return  EXIT_SUCCESS on success, EXIT_FAILURE otherwise
 */
static int cominitCryptoCreateUniqueString(unsigned char *uniqueString) {
    int result = EXIT_FAILURE;
    char buffer[256] = {0};

    FILE *file = fopen("/proc/sys/kernel/random/boot_id", "r");
    if (file) {
        if (fgets(buffer, sizeof(buffer), file)) {
            size_t n = strcspn(buffer, "\r\n");
            buffer[n] = '\0';
            if (mbedtls_sha256_ret((const unsigned char *)buffer, strlen(buffer), uniqueString, 0) == 0) {
                result = EXIT_SUCCESS;
            }
        }
        fclose(file);
    }

    return result;
}

int cominitCryptoCreatePassphrase(unsigned char *passphrase, size_t passphraseSize) {
    int result = EXIT_FAILURE;

    if (passphrase == NULL || passphraseSize <= 0) {
        cominitErrPrint("Invalid parameters");
    } else {
        mbedtls_entropy_context entropy = {0};
        mbedtls_ctr_drbg_context ctr = {0};

        mbedtls_entropy_init(&entropy);
        mbedtls_ctr_drbg_init(&ctr);

        unsigned char uniqueString[SHA256_LEN] = {0};
        unsigned char *uniqueStringPtr = uniqueString;
        size_t uniqueStringSize = SHA256_LEN;
        if (cominitCryptoCreateUniqueString(uniqueStringPtr) == EXIT_FAILURE) {
            cominitSensitivePrint("Creation of unique string failed");
            uniqueStringPtr = NULL;
            uniqueStringSize = 0;
        }

        int err = mbedtls_ctr_drbg_seed(&ctr, mbedtls_entropy_func, &entropy, uniqueStringPtr, uniqueStringSize);
        if (err == 0) {
            err = mbedtls_ctr_drbg_random(&ctr, passphrase, passphraseSize);
            if (err == 0) {
                result = EXIT_SUCCESS;
            }
        }

        mbedtls_ctr_drbg_free(&ctr);
        mbedtls_entropy_free(&entropy);
    }

    return result;
}
